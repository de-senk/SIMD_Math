
#module_parameters(SHOULD_HINT_LLVM_FOR_SIMD := true, VERBOSE := false, BACKWARD_COMPATIBILITY := false);

#scope_module
#import "Math";
#import "SIMD";
#import "Basic";
#scope_export
//#no_aoc  === no_array_order_check, in SIMD if the order of float order in memory operations doesnt matter like in the dot product or addition, we can use the fac no_aoc
//#no_abc  === no_array_bounds_check


//TODO: simd this, inserting assets here doesnt work, making this a ring buffer also doesnt work, idk how to tell llvm to vectorize this.
operator *[] :: (a: $T/SIMD_Array, index: int) -> *a.type {
        return *a.data[index];
}

//I define this separately because Im not sure if the operator[] generated by operator*[] gets vectorized, or at least idk howto measure it (in jai if you define *[] the compiler automatically defines [] for you sometimes)
operator [] :: (a: $T/SIMD_Array, index: int) -> a.type  {
        return a.data[index];
}


is_valid :: inline (a: $T/SIMD_Array) -> bool {
    for a.data {
        is_nan, is_inf := is_nan_is_inf(it);
        if is_nan || is_inf return false;
    }
    return true;
}

dot :: (a: $T/SIMD_Array, b: T) -> T.type {
    sum:T.type;
    for i: 0..a.count-1 sum += a.data[i] * b.data[i];
    return sum;
}

/*

FLOAT32_MIN        :: 0h00800000;
FLOAT32_MAX        :: 0h7F7FFFFF;
FLOAT32_INFINITY   :: 0h7F800000;
FLOAT32_NAN        :: 0h7FBFFFFF;

FLOAT64_MIN        :: 0h00100000_00000000;
FLOAT64_MAX        :: 0h7FEFFFFF_FFFFFFFF;
FLOAT64_INFINITY   :: 0h7FF00000_00000000;
FLOAT64_NAN        :: 0h7FF7FFFF_FFFFFFFF;
*/

//I cannot figure out a good name for these get_biggest_component_ignore_sign ?
abs_biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if abs(it) > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if it > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}





insert_12_13_and_so_on_row_major :: (ROW:int, COL:int) -> string #compile_time {
    builder: String_Builder;
    for r: 1..ROW { //this for first is memory layout _11 _12 _13 ... _21 _22 _23 ... like having [COL]float, if you want column major, just permute these for loops but you also need to change math ops I think?
        for c: 1..COL {
            if r > 9 || c > 9
                print_to_builder(*builder, "_%1_%2: float32;\n", r,c); //because when we have 11 and 2, and 1 and 12 they both generate _112, so we instead generate _11_2 and _1_12
            else
                print_to_builder(*builder, "_%1%2: float32;\n", r,c); //because when we have 11 and 2, and 1 and 12 they both generate _112, so we instead generate _11_2 and _1_12
        }
    }

    // log("placing\n %",builder_to_string(*builder));
    return builder_to_string(*builder);
}

//Matrix_ROW_COL -> Matrix_R_C -> Matrix_RC
Matrix_RC :: struct(ROW:int,COL:int, type: Type = float32) {
    // _11: type; generated by the instert procedure.
    #insert #run insert_12_13_and_so_on_row_major(ROW, COL);
    #place _11; v:      [ROW]       SIMD_Array(COL, type) = ---; // These are row vectors.
    #place _11; coef:   [ROW][COL]  type   = ---;
    #place _11; floats: [ROW* COL]  type  = ---;

    Row_Type    :: SIMD_Array(COL, type); //<- DOUBT AGAIN! //these are ok, I 5thuple checked! 100% this time!//what order were these comments on?-> //they were righ that order was bad->//they were wrong // are these in the correct order?// switched again back to original // TODO: try switching these
    Column_Type :: SIMD_Array(ROW, type); //are not these an array of pointers?

    IsMatrixFromMathModule :: true;
}





converges :: (m: $T/Matrix_RC, $strict: bool=false) -> bool, row: int{
    #assert((T.ROW + T.COL) % 2 == 0);
    is_strictly_diagonally_dominant := true; //stupid name, it should be , are abs of same row elements lower and not equal than diagonal element? well the name makes sense now.

    for row: 0 ..T.ROW - 1
    {
        current_row_diag_elem := abs(m.v[row].data[row]);
        same_row_sum: T.type;
        for col: 0..T.COL-1 if row != col then same_row_sum += abs(m.v[row].data[col]);
        #if strict
        is_strictly_diagonally_dominant = current_row_diag_elem > same_row_sum;
        else
        is_strictly_diagonally_dominant = current_row_diag_elem >= same_row_sum;
        // assert(is_strictly_diagonally_dominant ,"m is not strictly diagonally dominant\n m:%", m);
        if !is_strictly_diagonally_dominant return false, row;
    }
    return true, row=0;
    //we need another test too:  M: Matrix3, other test is finding eigenvalues of M and see if they are all less than 1
}

diagonals_are_zero :: (m: $T/Matrix_RC) -> bool {
    #assert((T.ROW + T.COL) % 2 == 0);
    for row: 0 ..T.ROW - 1
    {
        is_diagonal_NOT_zero := m.v[row].data[row]*m.v[row].data[row] == 0;
        // assert(is_diagonal_NOT_zero ,"m has diagonals with 0 \n m:%", m);
        if !is_diagonal_NOT_zero return false;
    }
    return true;
}

set_diagonals_broadcast :: (m: *$T/Matrix_RC, val: m.type) -> bool {
    //TODO: simd hint, but I dont use this anyways. Only for tests
    #assert((T.ROW + T.COL) % 2 == 0);
    for row: 0 ..T.ROW - 1
    {
        m.v[row].data[row] = val;
    }
    return true;
}

