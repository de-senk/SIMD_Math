#module_parameters(SHOULD_HINT_LLVM_FOR_SIMD := true, SHOULD_IMPORT_STUFF_THAT_SHOUL_NOT_BE_IN_THIS_MODULE:=true)(ENABLE_ASSERT := true);

#scope_file
#import "Math";
#import "SIMD";
#import "Basic";
#scope_export

#if SHOULD_IMPORT_STUFF_THAT_SHOUL_NOT_BE_IN_THIS_MODULE {

    Sign :: inline (x: float) -> float {
        return ifx x < 0 then -1.0 else (ifx x > 0 then 1.0 else 0.0);
    }
    operator * :: (q: Quaternion, v:Vector3) -> Vector3 #symmetric
    {
        u := Vector3.{q.x, q.y, q.z};
        s := q.w;

        // Compute v' = 2 * dot(u, v) * u + (s^2 - dot(u, u)) * v + 2 * s * cross(u, v)
        dot_u_v := dot(u, v);
        dot_u_u := dot(u, u);
        cross_u_v := cross(u, v);

        result := 2.0 * dot_u_v * u + (s * s - dot_u_u) * v + 2.0 * s * cross_u_v;
        return result;
    }

    operator * :: (m: Matrix4, v: Vector3) -> Vector3 {

        result: Vector3 = ---;
        tmp: Vector4 = ---;
        tmp.xyz = v;
        tmp.w = 1.0;

        r4 := inline multiply(m, tmp);
        result = r4.xyz;
        return result;
    }


    make_quaternion_from_axis_and_angle :: (axiss: Vector3, theta: float) -> Quaternion {
        using q: Quaternion = ---;
        axis := unit_vector(axiss);

        st := sin(theta * 0.5);
        ct := cos(theta * 0.5);

        x = axis.x * st;
        y = axis.y * st;
        z = axis.z * st;
        w = ct;
        return q;
    }
}
//should this be exported?
#load "epsilons.jai";

//#no_aoc  === no_array_order_check, in SIMD if the order of float order in memory operations doesnt matter like in the dot product or addition, we can use the fac no_aoc
//#no_abc  === no_array_bounds_check

//
// SECTON: IMD_Array
//




operator *[] :: (a: $T/SIMD_Array, $index: int) -> *a.type {
        #assert(index >= 0);
        #assert(index < a.count);
        return *a.data[index]; //TODO: simd this, inserting assets here doesnt work, making this a ring buffer also doesnt work, idk how to tell llvm to vectorize this.
}

// operator *[] :: (a: $T/SIMD_Array, index: int) -> *a.type {
//         return *a.data[index]; //TODO: simd this, inserting assets here doesnt work, making this a ring buffer also doesnt work, idk how to tell llvm to vectorize this.
// }

operator [] :: (a: $T/SIMD_Array, index: int) -> a.type  {
        return a.data[index]; //NOTE: I define this separately because Im not sure if the operator[] generated by operator*[] gets vectorized, or at least idk howto measure it (in jai if you define *[] the compiler automatically defines [] for you sometimes)
}


dot :: (a: $T/SIMD_Array, b: T) -> T.type {
    sum:T.type;
    for i: 0..a.count-1 sum += a.data[i] * b.data[i];
    return sum;
}

//I cannot figure out a good name for these get_biggest_component_ignore_sign ?
abs_biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if abs(it) > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if it > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

is_valid :: inline (a: $T/SIMD_Array) -> bool {
    for a.data {
        is_nan, is_inf := is_nan_is_inf(it);
        if is_nan || is_inf return false;
    }
    return true;
}

is_valid :: inline (a: int) -> bool {
    return true;
}

is_valid :: inline (a: float32) -> bool {
    is_nan, is_inf := is_nan_is_inf(a);
    return !is_nan;
}

is_valid :: inline (a: float64) -> bool {
    is_nan, is_inf := is_nan_is_inf(a);
    return !is_nan;
}

is_valid :: inline (a: Quaternion) -> bool {
    for a.component {
        is_nan, is_inf := is_nan_is_inf(it);
        if is_nan || is_inf return false;
    }
    if !is_normalized(a) return false;
    return true;
}

is_valid :: inline (a: $T/.[Vector2, Vector3, Vector4]) -> bool {
    for a.component {
    is_nan, is_inf := is_nan_is_inf(it);
    if is_nan || is_inf return false;
    }
    return true;
}


is_normalized :: (a: Quaternion, $tolerance:float = 0.000001) -> bool {
    sum: float;
    sum += a.w*a.w;
    sum += a.x*a.x;
    sum += a.y*a.y;
    sum += a.z*a.z;

    return sum < 1+tolerance && sum > 1-tolerance; //Already tested, its badn we should use 6 or less->should I use epsilon7? 7 digits are the limits of flaot precisions, but idk if the first 0. counts
}

is_normalized :: (a: $T / .[Vector2, Vector3, Vector4], $tolerance:float = 0.000001) -> bool {
    sum: float;
    for a.component {
        sum += it*it;
    }
    return sum < 1+tolerance && sum > 1-tolerance; //Already tested, its badn we should use 6 or less->should I use epsilon7? 7 digits are the limits of flaot precisions, but idk if the first 0. counts
}
//
// SECTON: Matrix_RC
//
insert_12_13_and_so_on_row_major :: (ROW:int, COL:int, $type: Type) -> string #compile_time {
    builder: String_Builder;
    for r: 1..ROW { //this for first is memory layout _11 _12 _13 ... _21 _22 _23 ... like having [COL]float, if you want column major, just permute these for loops but you also need to change math ops I think? <- Yes! you need to fix the math operations too if you permute these for loops
        for c: 1..COL {
            if r > 9 || c > 9
                print_to_builder(*builder, "_%1_%2: %;\n", r,c, type); //because when we have 11 and 2, and 1 and 12 they both generate _112, so we instead generate _11_2 and _1_12
            else
                print_to_builder(*builder, "_%1%2: %;\n", r,c, type); //to be compatible with the official Math module
        }
    }
    return builder_to_string(*builder);
}

//I defined these because otherwise covnerge procedure doesnt work when I replace type of Matri x to s16 and s8
abs :: inline (x: s16) -> s16 {
    if x < 0 return -x;
    return x;
}
abs :: inline (x: s8) -> s8 {
    if x < 0 return -x;
    return x;
}

//@Check I never remember the convention, I use this mnemmotech-> from far I see a matrix, I cannot see it from top because is too far, but I can see the side!, from the side it loos like it has R rows, so I wrtite Matrix_R when I get closer to the matrix I see the top and can count the columns, then I write Matrix_ RC  a matrix  of R rows and C columns
Matrix_RC :: struct(ROW:int,COL:int, type: Type = float32) {
    // _11: type; generated by the instert procedure.
    #insert #run insert_12_13_and_so_on_row_major(ROW, COL, type);
    #place _11; v:      [ROW]       SIMD_Array(COL, type) = ---; // These are row vectors.
    #place _11; coef:   [ROW][COL]  type   = ---;
    #place _11; floats: [ROW* COL]  type  = ---;

    Row_Type    :: SIMD_Array(COL, type); //<- DOUBT AGAIN! //these are ok, I 5thuple checked! 100% this time!//what order were these comments on?-> //they were righ that order was bad->//they were wrong // are these in the correct order?// switched again back to original // TODO: try switching these
    Column_Type :: SIMD_Array(ROW, type); //are not these an array of pointers?

    IsMatrixFromMathModule :: true;
    IS_SQUARED :bool: (ROW + COL) % 2 == 0;
}

operator * :: (A: $T/Matrix_RC, scalar: T.type)  -> T #symmetric {
    result := A;
    for r: 0..T.ROW-1 result.v[r] *= scalar ;
    return result;
}

//Matri[row][col]*column vector = columnt Vector   each dash is a slot-> A*b=c A *(----) = (----)
operator * :: (A: $T/Matrix_RC, b: T.Row_Type) -> T.Column_Type {
    #assert(T.COL == T.Row_Type.count);
    result: T.Column_Type = ---;
    for row: 0..T.ROW-1 result.data[row] = dot(A.v[row], b);
    return result;
}

//TODO: all this is confusing, the above is confusing too, because b: T.Row_Type instead of Column Type...
//row vector * Matrix = row vector |*M = |
// operator * :: (b: T.Row_Type, A: $T/Matrix_RC) -> T.Row_Type {
//     #assert(T.Row_Type.count == T.ROW);
//     result: T.Row_Type = ---;
//     for r: 0..T.ROW-1 result.data[r] = dot(A.v[r], b) ;
//     return result;
// }


insert_multiplciations_rc :: (ROW: int, COL: int) -> string {
    b: String_Builder;
    for row: 1..ROW
        for col: 1..COL
        {
            if row > 9 || col > 9
            print_to_builder(*b, "result._%1_%2 = dot(a.v[%3], b_transposed.v[%4]);", row, col, row-1, col-1);
            else
            print_to_builder(*b, "result._%1%2  = dot(a.v[%3], b_transposed.v[%4]);", row, col, row-1, col-1);
        }

    return builder_to_string(*b);
}

operator * :: (a: $T/Matrix_RC, b: $R/Matrix_RC) -> Matrix_RC(T.ROW, R.COL)
{
    // #assert(matrices_can_be_multiplied_together(T,R));
    IDK_MAN :: R.ROW != T.COL && R.COL != T.ROW;
    #assert(!IDK_MAN); //I cannot brain this for some reason, but I tested it and it works
    result: Matrix_RC(T.ROW, R.COL) = ---; //maybe = ---; I think not because not all fields get filled? TODO: @Investigate how to know when llvm omits zero-outing these.
    b_transposed := transpose(b); //this does not get inlined, decision by compiler, probably because registers count and not code size(is my guess)

    #if SHOULD_HINT_LLVM_FOR_SIMD {
        #insert #run insert_multiplciations_rc(T.ROW, R.COL); //[LLVM REPORT] SUCCESS I THINK
    } else {
        for row: 0..T.ROW-1 //I spent 1 day to figure this bug
        for col: 0..R.COL-1 { //[LLVM REPORT]loop not vectorized
            result.v[row][col] = dot(a.v[row], b_transposed.v[col]) ; //[LLVM REPORT]loop not vectorized: cannot identify array bounds
        }

    }
    return result;
}


insert_12_13_transpose:: (ROW:int, COL:int) -> string #compile_time {
    builder: String_Builder;
    for row: 1..ROW {
        for col: 1..COL {
                if row>9 || col> 9
                    print_to_builder(*builder, "result._%2_%1 = m._%1_%2 ;\n", row, col );
                else
                    print_to_builder(*builder, "result._%2%1 = m._%1%2 ;\n", row, col );
        }
    }
    return builder_to_string(*builder);
}

transpose :: (m: $T/Matrix_RC) -> Matrix_RC(m.COL, m.ROW) {
    result: Matrix_RC(m.COL, m.ROW) = ---;
    #if SHOULD_HINT_LLVM_FOR_SIMD {
        #insert #run insert_12_13_transpose(T.ROW, T.COL);
    } else {
        for row: 0..T.ROW-1 //we stay in row and traverse by column, cache line friendly
        for col: 0..T.COL-1 {
            result.coef[col][row] = m.coef[row][col]; //[LLVM REPORT]loop not vectorized: cannot identify array bounds
        }
    }
    return result;
}


converges :: (m: $T/Matrix_RC, $strict: bool=false) -> bool, row: int{
    #assert(m.IS_SQUARED);
    is_strictly_diagonally_dominant := true; //stupid name, it should be , are abs of same row elements lower and not equal than diagonal element? well the name makes sense now.

    for row: 0 ..T.ROW - 1
    {
        current_row_diag_elem := abs(m.v[row].data[row]);
        same_row_sum: T.type;
        for col: 0..T.COL-1 if row != col then same_row_sum += abs(m.v[row].data[col]);
        #if strict
        is_strictly_diagonally_dominant = current_row_diag_elem > same_row_sum;
        else
        is_strictly_diagonally_dominant = current_row_diag_elem >= same_row_sum;
        // assert(is_strictly_diagonally_dominant ,"m is not strictly diagonally dominant\n m:%", m);
        if !is_strictly_diagonally_dominant return false, row;
    }
    return true, row=0;
    //we need another test too:  M: Matrix3, other test is finding eigenvalues of M and see if they are all less than 1
}

diagonals_are_zero :: (m: $T/Matrix_RC) -> bool {
    #assert(m.IS_SQUARED);
    for row: 0 ..T.ROW - 1
    {
        is_diagonal_NOT_zero := m.v[row].data[row]*m.v[row].data[row] == 0;
        // assert(is_diagonal_NOT_zero ,"m has diagonals with 0 \n m:%", m);
        if !is_diagonal_NOT_zero return false;
    }
    return true;
}

//TODO: simd hint, but I dont use this anyways. Only for tests
set_diagonals_broadcast :: (m: *$T/Matrix_RC, val: m.type) -> bool {
    #assert(m.IS_SQUARED);
    for row: 0 ..T.ROW - 1
    {
        m.v[row].data[row] = val;
    }
    return true;
}



LCP_Gauss_Seidel :: (A: $T/Matrix_RC, b: T.Row_Type, $iterations: int = 1) -> T.Row_Type  {
    #assert(A.IS_SQUARED);
    // #assert(T.ROW == T.COL);
    // if diagonals_are_zero(A) then return .{}; //shortcut TODO: testin on shortcut enables
    #if ENABLE_ASSERT converges(A);
    //for convergence: //to Implement and delete these 3 lines of comments, repalce with asserts.
    //  a must be symmetric
    //  a must be positive definite || diagonally dominant
    result: T.Row_Type; //init to 0 is key here.
    for iter: 0..iterations - 1
    {
        for row: 0 ..T.ROW - 1
        {
            dx := (b.data[row] - dot(A.v[row], result)) / A.v[row].data[row];
            if is_valid(dx)
            {
                result.data[row] += dx;
            }
        }
    }
    return result;
}




broadcast_for_tests :: (a: *$T/SIMD_Array, $val: a.type) {
    insert_expansion :: ($count: int, val : $SIMD_type) -> string{
          the_code :=#string JAI
               a.*[%1] = %2;
            JAI
        sb: String_Builder;
        for it_index: 0..count-1{
            print_to_builder(*sb, the_code, it_index, val);
        }
        return builder_to_string(*sb);
    }
    #insert #run insert_expansion(a.count, val);
    // for i: 0..a.count-1 {
    //     a.*[i] = val;
    // }
}

broadcast_for_tests_interleave :: (a: *$T/SIMD_Array, $val: a.type, $step:= 1, $offset:= 0) {
    // for i: 0..a.count-1 {
    //     if i % (step) != 0 then continue;
    //     idx_to_use := i - offset;
    //     if idx_to_use > a.count-1 then continue;
    //     if idx_to_use < 0 then continue;
    //     a.*[idx_to_use] = val;
    // }

    insert_expansion :: ($count: int, val : $SIMD_type) -> string{
      the_code :=#string JAI
           a.*[%1] = %2;
        JAI
    sb: String_Builder;
    for i: 0..count-1{
        if i % (step) != 0 then continue;
        idx_to_use := i - offset;
        if idx_to_use > a.count-1 then continue;
        if idx_to_use < 0 then continue;
        print_to_builder(*sb, the_code, idx_to_use, val);
    }
    return builder_to_string(*sb);
}

    #insert #run insert_expansion(a.count, val);

}
