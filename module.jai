
#module_parameters(SHOULD_HINT_LLVM_FOR_SIMD := true, VERBOSE := false, BACKWARD_COMPATIBILITY := false);

#scope_module
#import "Math";
#import "SIMD";
#import "Basic";
#scope_export
//#no_aoc  === no_array_order_check, in SIMD if the order of float order in memory operations doesnt matter like in the dot product or addition, we can use the fac no_aoc
//#no_abc  === no_array_bounds_check


//TODO: simd this, inserting assets here doesnt work, making this a ring buffer also doesnt work, idk how to tell llvm to vectorize this.
operator *[] :: (a: $T/SIMD_Array, index: int) -> *a.type {
        return *a.data[index];
}

//I define this separately because Im not sure if the operator[] generated by operator*[] gets vectorized, or at least idk howto measure it (in jai if you define *[] the compiler automatically defines [] for you sometimes)
operator [] :: (a: $T/SIMD_Array, index: int) -> a.type  {
        return a.data[index];
}


is_valid :: inline (a: $T/SIMD_Array) -> bool {
    for a.data {
        is_nan, is_inf := is_nan_is_inf(it);
        if is_nan || is_inf return false;
    }
    return true;
}

dot :: (a: $T/SIMD_Array, b: T) -> T.type {
    sum:T.type;
    for i: 0..a.count-1 sum += a.data[i] * b.data[i];
    return sum;
}

/*

FLOAT32_MIN        :: 0h00800000;
FLOAT32_MAX        :: 0h7F7FFFFF;
FLOAT32_INFINITY   :: 0h7F800000;
FLOAT32_NAN        :: 0h7FBFFFFF;

FLOAT64_MIN        :: 0h00100000_00000000;
FLOAT64_MAX        :: 0h7FEFFFFF_FFFFFFFF;
FLOAT64_INFINITY   :: 0h7FF00000_00000000;
FLOAT64_NAN        :: 0h7FF7FFFF_FFFFFFFF;
*/

//I cannot figure out a good name for these get_biggest_component_ignore_sign ?
abs_biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if abs(it) > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if it > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

