
#module_parameters(SHOULD_HINT_LLVM_FOR_SIMD := true, VERBOSE := false, BACKWARD_COMPATIBILITY := false);

#scope_module
#import "Math";
#import "SIMD";
#import "Basic";
#scope_export
//#no_aoc  === no_array_order_check, in SIMD if the order of float order in memory operations doesnt matter like in the dot product or addition, we can use the fac no_aoc
//#no_abc  === no_array_bounds_check


//TODO: simd this, inserting assets here doesnt work, making this a ring buffer also doesnt work, idk how to tell llvm to vectorize this.
operator *[] :: (a: $T/SIMD_Array, index: int) -> *a.type {
        return *a.data[index];
}

//I define this separately because Im not sure if the operator[] generated by operator*[] gets vectorized, or at least idk howto measure it (in jai if you define *[] the compiler automatically defines [] for you sometimes)
operator [] :: (a: $T/SIMD_Array, index: int) -> a.type  {
        return a.data[index];
}


is_valid :: inline (a: $T/SIMD_Array) -> bool {
    for a.data {
        is_nan, is_inf := is_nan_is_inf(it);
        if is_nan || is_inf return false;
    }
    return true;
}

is_valid :: inline (a: int) -> bool {
    return true;
}
is_valid :: inline (a: float32) -> bool {
    is_nan, is_inf := is_nan_is_inf(a);
    return !is_nan;
}

is_valid :: inline (a: float64) -> bool {
    is_nan, is_inf := is_nan_is_inf(a);
    return !is_nan;
}

dot :: (a: $T/SIMD_Array, b: T) -> T.type {
    sum:T.type;
    for i: 0..a.count-1 sum += a.data[i] * b.data[i];
    return sum;
}

/*

FLOAT32_MIN        :: 0h00800000;
FLOAT32_MAX        :: 0h7F7FFFFF;
FLOAT32_INFINITY   :: 0h7F800000;
FLOAT32_NAN        :: 0h7FBFFFFF;

FLOAT64_MIN        :: 0h00100000_00000000;
FLOAT64_MAX        :: 0h7FEFFFFF_FFFFFFFF;
FLOAT64_INFINITY   :: 0h7FF00000_00000000;
FLOAT64_NAN        :: 0h7FF7FFFF_FFFFFFFF;
*/

//I cannot figure out a good name for these get_biggest_component_ignore_sign ?
abs_biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if abs(it) > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}

biggest :: (a:  $T/SIMD_Array) -> T.type, int {
    biggest: T.type;
    index: int;
    for a.data {
        if it > biggest {
            biggest = it;
            index = it_index;
        }
    }
    return biggest, index;
}





insert_12_13_and_so_on_row_major :: (ROW:int, COL:int, $type: Type) -> string #compile_time {
    builder: String_Builder;
    for r: 1..ROW { //this for first is memory layout _11 _12 _13 ... _21 _22 _23 ... like having [COL]float, if you want column major, just permute these for loops but you also need to change math ops I think?
        for c: 1..COL {
            if r > 9 || c > 9
                print_to_builder(*builder, "_%1_%2: %;\n", r,c, type); //because when we have 11 and 2, and 1 and 12 they both generate _112, so we instead generate _11_2 and _1_12
            else
                print_to_builder(*builder, "_%1%2: %;\n", r,c, type); //because when we have 11 and 2, and 1 and 12 they both generate _112, so we instead generate _11_2 and _1_12
        }
    }

    // log("placing\n %",builder_to_string(*builder));
    return builder_to_string(*builder);
}

//I defined these because otherwise covnerge procedure doesnt work
abs :: inline (x: s16) -> s16 {
    if x < 0 return -x;
    return x;
}
abs :: inline (x: s8) -> s8 {
    if x < 0 return -x;
    return x;
}

//Matrix_ROW_COL -> Matrix_R_C -> Matrix_RC
Matrix_RC :: struct(ROW:int,COL:int, type: Type = float64) {
    // _11: type; generated by the instert procedure.
    #insert #run insert_12_13_and_so_on_row_major(ROW, COL, type);
    #place _11; v:      [ROW]       SIMD_Array(COL, type) = ---; // These are row vectors.
    #place _11; coef:   [ROW][COL]  type   = ---;
    #place _11; floats: [ROW* COL]  type  = ---;

    Row_Type    :: SIMD_Array(COL, type); //<- DOUBT AGAIN! //these are ok, I 5thuple checked! 100% this time!//what order were these comments on?-> //they were righ that order was bad->//they were wrong // are these in the correct order?// switched again back to original // TODO: try switching these
    Column_Type :: SIMD_Array(ROW, type); //are not these an array of pointers?

    IsMatrixFromMathModule :: true;
}



operator * :: (A: $T/Matrix_RC, scalar: T.type)  -> T #symmetric {
    result := A;
    for r: 0..T.ROW-1 result.v[r] *= scalar ;
    return result;
}

//Matrix*column vector = columnt Vector   each dash is a slot-> A*b=c A *(----) = (----)
operator * :: (A: $T/Matrix_RC, b: T.Row_Type) -> T.Column_Type {
    #assert(T.COL == T.Row_Type.count);
    result: T.Column_Type = ---;
    for row: 0..T.ROW-1 result.data[row] = dot(A.v[row], b) ;
    return result;
}

//TODO: all this is confusing, the above is confusing too, because b: T.Row_Type instead of Column Type...
//row vector * Matrix = row vector |*M = |
// operator * :: (b: T.Row_Type, A: $T/Matrix_RC) -> T.Row_Type {
//     #assert(T.Row_Type.count == T.ROW);
//     result: T.Row_Type = ---;
//     for r: 0..T.ROW-1 result.data[r] = dot(A.v[r], b) ;
//     return result;
// }


insert_multiplciations_rc :: (ROW: int, COL: int) -> string {
    b: String_Builder;
    for row: 1..ROW
        for col: 1..COL
        {
            if row > 9 || col > 9
            print_to_builder(*b, "result._%1_%2 = dot(a.v[%3], b_transposed.v[%4]);", row, col, row-1, col-1);
            else
            print_to_builder(*b, "result._%1%2  = dot(a.v[%3], b_transposed.v[%4]);", row, col, row-1, col-1);
        }

    return builder_to_string(*b);
}

operator * :: (a: $T/Matrix_RC, b: $R/Matrix_RC) -> Matrix_RC(T.ROW, R.COL)
{
    // #assert(matrices_can_be_multiplied_together(T,R));
    IDK_MAN :: R.ROW != T.COL && R.COL != T.ROW;
    #assert(!IDK_MAN); //I cannot brain this for some reason, but I tested it and it works
    result: Matrix_RC(T.ROW, R.COL) = ---; //maybe = ---; I think not because not all fields get filled? TODO: @Investigate how to know when llvm omits zero-outing these.
    b_transposed := transpose(b); //this does not get inlined, decision by compiler, probably because registers count and not code size(is my guess)

    #if SHOULD_HINT_LLVM_FOR_SIMD {
        #insert #run insert_multiplciations_rc(T.ROW, R.COL); //[LLVM REPORT] SUCCESS I THINK
    } else {
        for row: 0..T.ROW-1 //I spent 1 day to figure this bug
        for col: 0..R.COL-1 { //[LLVM REPORT]loop not vectorized
            result.v[row][col] = dot(a.v[row], b_transposed.v[col]) ; //[LLVM REPORT]loop not vectorized: cannot identify array bounds
        }

    }
    return result;
}




insert_12_13_transpose:: (ROW:int, COL:int) -> string #compile_time {
    builder: String_Builder;
    for row: 1..ROW {
        for col: 1..COL {
                if row>9 || col> 9
                    print_to_builder(*builder, "result._%2_%1 = m._%1_%2 ;\n", row, col );
                else
                    print_to_builder(*builder, "result._%2%1 = m._%1%2 ;\n", row, col );
        }
    }
    return builder_to_string(*builder);
}

transpose :: (m: $T/Matrix_RC) -> Matrix_RC(m.COL, m.ROW) {
    result: Matrix_RC(m.COL, m.ROW) = ---;
    #if SHOULD_HINT_LLVM_FOR_SIMD {
        #insert #run insert_12_13_transpose(T.ROW, T.COL);
    } else {
        for row: 0..T.ROW-1 //we stay in row and traverse by column, cache line friendly
        for col: 0..T.COL-1 {
            result.coef[col][row] = m.coef[row][col]; //[LLVM REPORT]loop not vectorized: cannot identify array bounds
        }
    }
    return result;
}


converges :: (m: $T/Matrix_RC, $strict: bool=false) -> bool, row: int{
    #assert((T.ROW + T.COL) % 2 == 0);
    is_strictly_diagonally_dominant := true; //stupid name, it should be , are abs of same row elements lower and not equal than diagonal element? well the name makes sense now.

    for row: 0 ..T.ROW - 1
    {
        current_row_diag_elem := abs(m.v[row].data[row]);
        same_row_sum: T.type;
        for col: 0..T.COL-1 if row != col then same_row_sum += abs(m.v[row].data[col]);
        #if strict
        is_strictly_diagonally_dominant = current_row_diag_elem > same_row_sum;
        else
        is_strictly_diagonally_dominant = current_row_diag_elem >= same_row_sum;
        // assert(is_strictly_diagonally_dominant ,"m is not strictly diagonally dominant\n m:%", m);
        if !is_strictly_diagonally_dominant return false, row;
    }
    return true, row=0;
    //we need another test too:  M: Matrix3, other test is finding eigenvalues of M and see if they are all less than 1
}

diagonals_are_zero :: (m: $T/Matrix_RC) -> bool {
    #assert((T.ROW + T.COL) % 2 == 0);
    for row: 0 ..T.ROW - 1
    {
        is_diagonal_NOT_zero := m.v[row].data[row]*m.v[row].data[row] == 0;
        // assert(is_diagonal_NOT_zero ,"m has diagonals with 0 \n m:%", m);
        if !is_diagonal_NOT_zero return false;
    }
    return true;
}

set_diagonals_broadcast :: (m: *$T/Matrix_RC, val: m.type) -> bool {
    //TODO: simd hint, but I dont use this anyways. Only for tests
    #assert((T.ROW + T.COL) % 2 == 0);
    for row: 0 ..T.ROW - 1
    {
        m.v[row].data[row] = val;
    }
    return true;
}



//@Check I never remember the convention, I use this mnemmotech-> from far I see a matrix, I cannot see it from top because is too far, but from the side it loos like it has R rows, so I wrtite Matrix_R when I get closer to the matrix I see the top and can count them, then I write Matrix_ RC  a matrix  of R rows and C columns
LCP_Gauss_Seidel :: (A: $T/Matrix_RC, b: T.Row_Type, $iterations: int = 1) -> T.Row_Type
// #modify {
//         return (T.ROW + T.COL) % 2 == 0; //maybe replace with bitwise, Since I dont use bitwise everyday I forget, is it (A.ROW | A.COL) & 1 == 0 ?
//     }
    {
    #assert((T.ROW + T.COL) % 2 == 0);
    // #assert(T.ROW == T.COL);
    // if diagonals_are_zero(A) then return .{};
    converges(A);
    //for convergence: //to Implement and delete these 3 lines of comments, repalce with asserts.
    //  a must be symmetric
    //  a must be positive definite || diagonally dominant
    result: T.Row_Type; //init to 0 is key here.
    for iter: 0..iterations - 1
    {
        for row: 0 ..T.ROW - 1
        {
            dx := (b.data[row] - dot(A.v[row], result)) / A.v[row].data[row];
            if is_valid(dx)
            {
                result.data[row] += dx;
                // log("row %", (b.data[row] - dot(A.v[row], result)));
                // log("asd %", A);
            }
        }
    }
    return result;
}
